"use strict";(globalThis.webpackChunkjob=globalThis.webpackChunkjob||[]).push([[4342],{5455:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var n=i(8168),a=(i(6540),i(5680));const r={sidebar_position:3,slug:"/algorithms",title:"Algorithms"},o="Algorithms",s={unversionedId:"algorithms/index",id:"algorithms/index",title:"Algorithms",description:"An algorithm is a step-by-step procedure for solving a problem. It is a set of instructions or rules that can be followed to accomplish a specific task.",source:"@site/interview/algorithms/index.md",sourceDirName:"algorithms",slug:"/algorithms",permalink:"/algorithms",draft:!1,editUrl:"https://github.com/izemil/job/edit/master/interview/algorithms/index.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,slug:"/algorithms",title:"Algorithms"},sidebar:"tutorialSidebar",previous:{title:"What is Memoization?",permalink:"/questions/common/what-is-memoization"},next:{title:"Data Structures",permalink:"/algorithms/data-structures"}},l={},m=[{value:"Common definitions",id:"common-definitions",level:2},{value:"Sorting",id:"sorting",level:3},{value:"Searching",id:"searching",level:3},{value:"Recursion",id:"recursion",level:3},{value:"Greedy Algorithm",id:"greedy-algorithm",level:3},{value:"Dynamic Programming",id:"dynamic-programming",level:3},{value:"Divide and Conquer",id:"divide-and-conquer",level:3},{value:"Backtracking",id:"backtracking",level:3},{value:"Graph algorithms",id:"graph-algorithms",level:3},{value:"Heuristics",id:"heuristics",level:3},{value:"Approximation Algorithms",id:"approximation-algorithms",level:3},{value:"Randomized Algorithms",id:"randomized-algorithms",level:3}],c={toc:m},g="wrapper";function u({components:e,...t}){return(0,a.yg)(g,(0,n.A)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"algorithms"},"Algorithms"),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"An algorithm is a step-by-step procedure for solving a problem. It is a set of instructions or rules that can be followed to accomplish a specific task.")),(0,a.yg)("p",null,"As a JavaScript developer, you can start learning algorithms by following these steps:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Study basic algorithms and data structures in JavaScript.")," Start by learning about common algorithms and data structures that are commonly implemented in JavaScript, such as sorting algorithms (e.g. bubble sort, quick sort), searching algorithms (e.g. linear search, binary search), and data structures (e.g. arrays, linked lists, stacks, queues, trees)."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Practice solving problems using JavaScript.")," Try solving coding challenges on websites like LeetCode, HackerRank, and CodeForces that allow you to use JavaScript as a solution."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Practice with JavaScript libraries and frameworks for implementing algorithms.")," JavaScript has a number of libraries and frameworks such as D3.js and Chart.js, Tensorflow.js, etc. that can be used to implement various algorithms."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Dive deeper into specific areas of interest.")," Once you have a solid understanding of basic algorithms and data structures, you can start exploring more specialized areas such as machine learning, computer vision, natural language processing, and graph algorithms using JavaScript libraries and frameworks.")),(0,a.yg)("h2",{id:"common-definitions"},"Common definitions"),(0,a.yg)("h3",{id:"sorting"},"Sorting"),(0,a.yg)("p",null,"Sorting is the process of arranging a collection of items in a particular order. Common sorting algorithms include bubble sort, insertion sort, merge sort, quicksort, and radix sort."),(0,a.yg)("h3",{id:"searching"},"Searching"),(0,a.yg)("p",null,"Searching is the process of finding an element in a collection of items. Common searching algorithms include linear search and binary search."),(0,a.yg)("h3",{id:"recursion"},"Recursion"),(0,a.yg)("p",null,"Recursion is a technique where a function calls itself to solve a problem. Recursive algorithms can be used to solve problems that can be broken down into smaller subproblems of the same type."),(0,a.yg)("h3",{id:"greedy-algorithm"},"Greedy Algorithm"),(0,a.yg)("p",null,"A greedy algorithm is an algorithm that makes a locally optimal choice at each step, with the hope of finding a global optimal solution. This can lead to a highly efficient algorithm, but it doesn't always guarantee an optimal solution."),(0,a.yg)("p",null,"Here's an example of a greedy algorithm in JavaScript that solves the problem of finding the minimum number of coins needed to make a certain amount of change:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"function minCoins(coins, amount) {\n    let minCoins = 0;\n    for (let i = coins.length - 1; i >= 0; i--) {\n        while (amount >= coins[i]) {\n            amount -= coins[i];\n            minCoins++;\n        }\n    }\n    return minCoins;\n}\n")),(0,a.yg)("p",null,"In this example, the algorithm takes an array of coin denominations and the desired amount of change as inputs. It starts by iterating through the coin denominations array in descending order, trying to use the largest coin denomination possible. For each coin denomination, it repeatedly subtracts that coin value from the desired amount until the coin value is greater than the remaining amount. Each time it subtracts a coin denomination, it increments a minCoins counter. The algorithm stops when the remaining amount is zero, and the minCoins counter gives the minimum number of coins needed to make the desired amount of change."),(0,a.yg)("p",null,"Note that this example is not the only way to solve the problem, and the greedy algorithm may not always give the optimal solution."),(0,a.yg)("h3",{id:"dynamic-programming"},"Dynamic Programming"),(0,a.yg)("p",null,"Dynamic programming is a technique for solving problems by breaking them down into smaller subproblems, and solving each subproblem only once and storing the results for future use."),(0,a.yg)("h3",{id:"divide-and-conquer"},"Divide and Conquer"),(0,a.yg)("p",null,"Divide and conquer is a technique for solving problems by breaking them down into smaller subproblems that can be solved independently. It's similar to the technique of recursion, but generally better for optimization problems."),(0,a.yg)("h3",{id:"backtracking"},"Backtracking"),(0,a.yg)("p",null,"Backtracking is a technique for solving problems by trying out different solutions, and undoing the steps of a solution that leads to failure."),(0,a.yg)("h3",{id:"graph-algorithms"},"Graph algorithms"),(0,a.yg)("p",null,"Graph algorithms are a set of algorithms that operate on graph data structures. Some common graph algorithms include depth-first search, breadth-first search, shortest path algorithms and etc."),(0,a.yg)("h3",{id:"heuristics"},"Heuristics"),(0,a.yg)("p",null,"Heuristics are problem-solving strategies that are not guaranteed to find an optimal solution, but are often used in situations where an optimal solution cannot be found in a reasonable amount of time, but a good enough solution is needed quickly. Heuristics are often used in optimization problems, like the travelling salesman problem."),(0,a.yg)("h3",{id:"approximation-algorithms"},"Approximation Algorithms"),(0,a.yg)("p",null,"Approximation algorithms are algorithms that are designed to find approximate solutions to optimization problems, rather than exact solutions."),(0,a.yg)("h3",{id:"randomized-algorithms"},"Randomized Algorithms"),(0,a.yg)("p",null,"Randomized algorithms are algorithms that incorporate randomness in their execution. They can be used for tasks such as searching, sorting, and optimization."))}u.isMDXComponent=!0},5680:(e,t,i)=>{i.d(t,{xA:()=>c,yg:()=>d});var n=i(6540);function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function r(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),i.push.apply(i,n)}return i}function o(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?r(Object(i),!0).forEach(function(t){a(e,t,i[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))})}return e}function s(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var l=n.createContext({}),m=function(e){var t=n.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):o(o({},t),e)),i},c=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef(function(e,t){var i=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),g=m(i),h=a,d=g["".concat(l,".").concat(h)]||g[h]||u[h]||r;return i?n.createElement(d,o(o({ref:t},c),{},{components:i})):n.createElement(d,o({ref:t},c))});function d(e,t){var i=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=i.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[g]="string"==typeof e?e:a,o[1]=s;for(var m=2;m<r;m++)o[m]=i[m];return n.createElement.apply(null,o)}return n.createElement.apply(null,i)}h.displayName="MDXCreateElement"}}]);