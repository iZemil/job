"use strict";(globalThis.webpackChunkjob=globalThis.webpackChunkjob||[]).push([[2970],{4126:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var a=n(8168),r=(n(6540),n(5680));const s={},i="What is an abstract class?",o={unversionedId:"questions/typescript/abstract-class",id:"questions/typescript/abstract-class",title:"What is an abstract class?",description:"It is a class that cannot be instantiated directly, and that is intended to be used as a base class for one or more derived classes. Abstract classes are used to define the common behavior and the shared structure of a group of related classes, and they provide a way to implement inheritance and polymorphism in TypeScript.",source:"@site/interview/questions/typescript/abstract-class.md",sourceDirName:"questions/typescript",slug:"/questions/typescript/abstract-class",permalink:"/questions/typescript/abstract-class",draft:!1,editUrl:"https://github.com/izemil/job/edit/master/interview/questions/typescript/abstract-class.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Typescript Questions",permalink:"/questions/typescript/"},next:{title:"Explain `any` vs `unknown`",permalink:"/questions/typescript/any-vs-unknown"}},c={},l=[{value:"abstract classes vs interfaces",id:"abstract-classes-vs-interfaces",level:2}],p={toc:l},d="wrapper";function u({components:e,...t}){return(0,r.yg)(d,(0,a.A)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"what-is-an-abstract-class"},"What is an abstract class?"),(0,r.yg)("p",null,"It is a class that cannot be instantiated directly, and that is intended to be used as a base class for one or more derived classes. Abstract classes are used to define the common behavior and the shared structure of a group of related classes, and they provide a way to implement inheritance and polymorphism in TypeScript."),(0,r.yg)("p",null,"An abstract class is defined using the ",(0,r.yg)("inlineCode",{parentName:"p"},"abstract")," keyword, and it can contain both abstract and concrete members. Abstract members are members that are declared but not implemented, and they must be implemented by the derived classes. Concrete members are members that are declared and implemented, and they can be used directly by the derived classes."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-ts"},"abstract class Entity {\n    id: number;\n    name: string;\n\n    constructor(id: number, name: string) {\n        this.id = id;\n        this.name = name;\n    }\n\n    abstract getName(): string;\n\n    getMeta() {\n        return {\n            id: this.id,\n            name: this.title,\n        }\n    }\n}\n\nconst entity1 = new Entity(1, 'entity'); // Cannot create an instance of an abstract class.\n\n// instead of above\nclass Person extends Entity {\n    constructor(id: number) {\n        super(id, 'person')\n    }\n\n    getName() {\n        return Person.name;\n    }\n}\n\nconst person1 = new Person(1);\n")),(0,r.yg)("h2",{id:"abstract-classes-vs-interfaces"},"abstract classes vs interfaces"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Main differences:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"abstract classes can contain real implementation with logic for methods"),(0,r.yg)("li",{parentName:"ul"},"and the implemented methods can refer to other methods that do not actually exist yet (you still have to provide names and types for the unimplemented methods)"),(0,r.yg)("li",{parentName:"ul"},"abstract classes are available at runtime, while interfaces are compiled time only. This means that you cannot, for example, use\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"instanceof"),"\xa0with interfaces.")))}u.isMDXComponent=!0},5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>y});var a=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef(function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=l(n),m=r,y=d["".concat(c,".").concat(m)]||d[m]||u[m]||s;return n?a.createElement(y,i(i({ref:t},p),{},{components:n})):a.createElement(y,i({ref:t},p))});function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=m;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[d]="string"==typeof e?e:r,i[1]=o;for(var l=2;l<s;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);